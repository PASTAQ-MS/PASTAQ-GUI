Index: src/app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import inspect\r\nimport json\r\nimport os\r\nimport platform\r\nimport sys\r\nimport time\r\nimport resources\r\nimport platform\r\nimport pathlib\r\nimport subprocess\r\nimport sys\r\n\r\nfrom pathlib import Path\r\nfrom PyQt5.QtWidgets import QMainWindow, QApplication\r\nfrom PyQt5.QtCore import *\r\nfrom PyQt5.QtGui import QIcon, QKeySequence, QPalette, QColor\r\nfrom PyQt5.QtWidgets import *\r\n\r\nimport pastaq\r\n# sonarqube just for me (kaitlin):\r\n# C:\\Users\\kaitl\\Downloads\\sonarqube-9.3.0.51899\\sonarqube-9.3.0.51899\\bin\\windows-x86-64\\StartSonar.bat\r\n# http://localhost:9000/dashboard?id=pastaq\r\n# sonar-scanner.bat -D'sonar.projectKey=pastaq' -D'sonar.sources=.' -D'sonar.host.url=http://localhost:9000' -D'sonar.login=admin' -D'sonar.password=Dogukan69'\r\n\r\n# TODO: Create custom file picker widget that shows the name of the picked files\r\n# TODO: Switch the cwd to the project directory and/or use it instead of os.getcwd()\r\n# TODO: The RUN button should only be access when there is at least 1 sample active.\r\n\r\n# Window when you edit row(s)\r\nclass EditFileDialog(QDialog):\r\n    group = ''\r\n    mzid_paths = []\r\n\r\n    def __init__(self, parent=None):\r\n        super().__init__(parent)\r\n\r\n        # TODO: Set fixed size for this.\r\n        self.setStyleSheet(\"background-color: Grey;\")\r\n        self.setWindowTitle('PASTAQ: DDA Pipeline - Add files')\r\n\r\n        # Edit parameters.\r\n        form_container = QWidget()\r\n        form_layout = QFormLayout()\r\n        self.group_box = QLineEdit()\r\n        self.group_box.textChanged.connect(self.set_group)\r\n        mzid_picker = QPushButton('Browse')\r\n        mzid_picker.clicked.connect(self.set_mzid_paths)\r\n        # start of drag and drop\r\n        # drop = ImageLabel()\r\n        # self.setAcceptDrops(True)\r\n\r\n        form_layout.addRow('Group', self.group_box)\r\n        form_layout.addRow('mgf/mzID', mzid_picker)\r\n        # form_layout.addRow(drop)\r\n\r\n        form_container.setLayout(form_layout)\r\n\r\n        # Dialog buttons (Ok/Cancel).\r\n        dialog_buttons = QDialogButtonBox.Ok | QDialogButtonBox.Cancel\r\n        buttons = QDialogButtonBox(dialog_buttons)\r\n        buttons.accepted.connect(self.accept)\r\n        buttons.rejected.connect(self.reject)\r\n\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(form_container)\r\n        layout.addWidget(buttons)\r\n        self.setLayout(layout)\r\n\r\n    # TODO\r\n    def dragEnterEvent(self, event):\r\n        if event.mimeData().hasUrls():\r\n            event.accept()\r\n        else:\r\n            event.ignore()\r\n\r\n    def dropEvent(self, event):\r\n        files = [u.toLocalFile() for u in event.mimeData().urls()]\r\n        #\r\n        for f in files:\r\n            print(f)\r\n\r\n    def set_group(self):\r\n        self.group = self.group_box.text()\r\n\r\n    def set_mzid_paths(self):\r\n        file_paths, _ = QFileDialog.getOpenFileNames(\r\n            parent=self,\r\n            caption='Select input files',\r\n            directory=os.getcwd(),\r\n            # two extension possibilities\r\n            filter='Identification files (*.mzID *.mzIdentML *.mgf)'\r\n        )\r\n        if len(file_paths) > 0:\r\n            self.mzid_paths = file_paths\r\n\r\n# class for drag and drop field\r\nclass ImageLabel(QLabel):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        self.setAlignment(Qt.AlignCenter)\r\n        self.setText('\\n\\n Drop File(s) Here \\n\\n')\r\n        self.setStyleSheet('''\r\n            QLabel{\r\n                border: 4px dashed #aaa\r\n            }\r\n        ''')\r\n\r\n    def setPixmap(self, image):\r\n        super().setPixmap(image)\r\n\r\n\r\nclass ParameterItem(QWidget):\r\n    def __init__(self, label, tooltip, widget, parent=None):\r\n        QWidget.__init__(self, parent=parent)\r\n        layout = QVBoxLayout(self)\r\n\r\n        button = QPushButton(label, self)\r\n        button.setToolTip(tooltip)\r\n\r\n        icon = QIcon(':/icons/question.png')\r\n        button.setLayoutDirection(Qt.RightToLeft)\r\n        button.setIcon(icon)\r\n        button.setStyleSheet('border: none;')\r\n\r\n        layout.addWidget(button)\r\n        layout.addWidget(widget)\r\n\r\n\r\nclass TextStream(QObject):\r\n    text_written = pyqtSignal(str)\r\n\r\n    def write(self, text):\r\n        self.text_written.emit(str(text))\r\n\r\n\r\nclass PipelineRunner(QThread):\r\n    finished = pyqtSignal()\r\n\r\n    params = {}\r\n    input_files = []\r\n    output_dir = ''\r\n\r\n    def __init__(self):\r\n        QThread.__init__(self)\r\n\r\n    def __del__(self):\r\n        self.wait()\r\n\r\n    def run(self):\r\n        print('Starting DDA Pipeline')\r\n        time.sleep(1)\r\n\r\n        try:\r\n            pastaq.dda_pipeline(self.params, self.input_files, self.output_dir)\r\n        except Exception as e:\r\n            print('ERROR:', e)\r\n\r\n        self.finished.emit()\r\n\r\n\r\nclass PipelineLogDialog(QDialog):\r\n    group = ''\r\n    mzid_paths = []\r\n\r\n    def __init__(self, params, input_files, output_dir, parent=None):\r\n        super().__init__(parent)\r\n\r\n        # TODO: Set fixed size for this.\r\n        self.setWindowTitle('PASTAQ: DDA Pipeline (Running)')\r\n\r\n        # Add custom output to text stream.\r\n        sys.stdout = TextStream(text_written=self.append_text)\r\n\r\n        # Log text box.\r\n        self.text_box = QTextEdit()\r\n        self.text_box.setReadOnly(True)\r\n\r\n        # Dialog buttons (Ok/Cancel).\r\n        self.buttons = QDialogButtonBox(QDialogButtonBox.Cancel)\r\n        self.buttons.rejected.connect(self.exit_failure)\r\n\r\n        # Prepare layout.\r\n        self.layout = QVBoxLayout()\r\n        self.layout.addWidget(self.text_box)\r\n        self.layout.addWidget(self.buttons)\r\n        self.setLayout(self.layout)\r\n\r\n        self.pipeline_thread = PipelineRunner()\r\n        self.pipeline_thread.params = params\r\n        self.pipeline_thread.input_files = input_files\r\n        self.pipeline_thread.output_dir = output_dir\r\n        self.pipeline_thread.finished.connect(self.exit_success)\r\n        self.pipeline_thread.start()\r\n\r\n    def __del__(self):\r\n        sys.stdout = sys.__stdout__\r\n\r\n    def append_text(self, text):\r\n        cursor = self.text_box.textCursor()\r\n        cursor.movePosition(cursor.End)\r\n        cursor.insertText(text)\r\n        self.text_box.setTextCursor(cursor)\r\n        self.text_box.ensureCursorVisible()\r\n\r\n    def exit_success(self):\r\n        # Restore stdout pipe.\r\n        sys.stdout = sys.__stdout__\r\n\r\n        # Replace button to OK instead of Cancel.\r\n        new_buttons = QDialogButtonBox(QDialogButtonBox.Ok)\r\n        new_buttons.accepted.connect(self.accept)\r\n        self.buttons.clear()\r\n        self.layout.replaceWidget(self.buttons, new_buttons)\r\n        self.buttons = new_buttons\r\n\r\n    def exit_failure(self):\r\n        # TODO: Confirm we want to exit, since this could lead to corrupt\r\n        # temporary files.\r\n\r\n        # Restore stdout pipe.\r\n        sys.stdout = sys.__stdout__\r\n        self.pipeline_thread.quit()\r\n        self.reject()\r\n\r\n# PASTAQ window\r\nclass ParametersWidget(QTabWidget):\r\n    input_files = []\r\n    parameters = {}\r\n    ms_jar = \"\"\r\n    id_file = \"\"\r\n    fasta = \"\"\r\n\r\n    def __init__(self, parent=None):\r\n        super(ParametersWidget, self).__init__(parent)\r\n        self.input_files_tab = QWidget()\r\n        self.parameters_tab = QScrollArea()\r\n        self.input_paths_tab = QScrollArea()\r\n\r\n        self.addTab(self.input_files_tab, 'Input files')\r\n        self.addTab(self.parameters_tab, 'Parameters')\r\n        self.addTab(self.input_paths_tab, 'Paths')\r\n        self.input_files_tab_ui()\r\n        self.parameters_tab_ui()\r\n        self.input_paths_tab_ui()\r\n\r\n    def input_files_tab_ui(self):\r\n        self.input_files_table = QTableWidget()\r\n        self.input_files_table.setEditTriggers(QTableWidget.NoEditTriggers)\r\n        self.input_files_table.setSelectionBehavior(QTableWidget.SelectRows)\r\n        self.input_files_table.setRowCount(0)\r\n        self.input_files_table.setColumnCount(4)\r\n        self.input_files_table.setFocusPolicy(False)\r\n        column_names = [\r\n            'Raw File (mzXML/mzML)',\r\n            'Identification file (mzID)',\r\n            'Group',\r\n            'Reference'\r\n        ]\r\n        self.input_files_table.setHorizontalHeaderLabels(column_names)\r\n        self.input_files_table.verticalHeader().hide()\r\n        header = self.input_files_table.horizontalHeader()\r\n        header.setSectionResizeMode(0, QHeaderView.Stretch)\r\n        header.setSectionResizeMode(1, QHeaderView.Stretch)\r\n        header.setSectionResizeMode(2, QHeaderView.ResizeToContents)\r\n        header.setSectionResizeMode(3, QHeaderView.ResizeToContents)\r\n\r\n        # Buttons.\r\n        self.add_file_btn = QPushButton('Add')\r\n        self.add_file_btn.clicked.connect(self.add_file)\r\n        self.edit_file_btn = QPushButton('Edit')\r\n        self.edit_file_btn.clicked.connect(self.edit_file)\r\n        self.remove_file_btn = QPushButton('Remove')\r\n        self.remove_file_btn.clicked.connect(self.remove_file)\r\n        self.remove_all_files_btn = QPushButton(\"Remove All\")\r\n        self.remove_all_files_btn.clicked.connect(self.remove_all_files)\r\n\r\n        self.input_file_buttons = QWidget()\r\n        controls_layout = QHBoxLayout()\r\n        controls_layout.addWidget(self.add_file_btn)\r\n        controls_layout.addWidget(self.edit_file_btn)\r\n        controls_layout.addWidget(self.remove_file_btn)\r\n        controls_layout.addWidget(self.remove_all_files_btn)\r\n        self.input_file_buttons.setLayout(controls_layout)\r\n\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(self.input_file_buttons)\r\n        layout.addWidget(self.input_files_table)\r\n        self.input_files_tab.setLayout(layout)\r\n\r\n    def input_paths_tab_ui(self):\r\n        msfragger_box = QGroupBox('MSFragger')\r\n        lay_ms = QHBoxLayout()\r\n        input_ms = QLineEdit()\r\n        input_ms.setText(self.ms_jar)\r\n        browse_button_ms = QPushButton('Browse')\r\n        browse_button_ms.clicked.connect(lambda: self.set_jar_path(input_ms))\r\n        check_ms = QPushButton('Confirm')\r\n        check_ms.clicked.connect(lambda: self.check_ms(input_ms))\r\n        lay_ms.addWidget(input_ms)\r\n        lay_ms.addWidget(browse_button_ms)\r\n        lay_ms.addWidget(check_ms)\r\n        msfragger_box.setLayout(lay_ms)\r\n\r\n        id_box = QGroupBox('idconvert')\r\n        lay_id = QHBoxLayout()\r\n        input_id = QLineEdit()\r\n        input_id.setText(self.id_file)\r\n        browse_button_id = QPushButton('Browse')\r\n        browse_button_id.clicked.connect(lambda: self.set_id_path(input_id))\r\n        check_id_button = QPushButton('Confirm')\r\n        check_id_button.clicked.connect(lambda: self.check_id(input_id))\r\n        lay_id.addWidget(input_id)\r\n        lay_id.addWidget(browse_button_id)\r\n        lay_id.addWidget(check_id_button)\r\n        id_box.setLayout(lay_id)\r\n\r\n        db_box = QGroupBox('Protein database')\r\n        lay_db = QHBoxLayout()\r\n        input_fasta = QLineEdit()\r\n        input_fasta.setText(self.id_file)\r\n        browse_button_fasta = QPushButton('Browse')\r\n        browse_button_fasta.clicked.connect(lambda: self.set_fasta_path(input_fasta))\r\n        check_fasta_button = QPushButton('Confirm')\r\n        check_fasta_button.clicked.connect(lambda: self.check_fasta(input_fasta))\r\n        lay_db.addWidget(input_fasta)\r\n        lay_db.addWidget(browse_button_fasta)\r\n        lay_db.addWidget(check_fasta_button)\r\n        db_box.setLayout(lay_db)\r\n\r\n        widget = QWidget()\r\n        self.input_paths_tab.setWidget(widget)\r\n        self.input_paths_tab.setWidgetResizable(True)\r\n\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(msfragger_box)\r\n        layout.addWidget(id_box)\r\n        layout.addWidget(db_box)\r\n\r\n        widget.setLayout(layout)\r\n\r\n    # browse for msfragger .jar file\r\n    def set_jar_path(self, input):\r\n        jar, _ = QFileDialog.getOpenFileName(\r\n            parent=self,\r\n            caption='Select MSFragger .jar file',\r\n            directory=os.getcwd(),\r\n            filter= 'jar (*.jar)'\r\n        )\r\n        if len(jar) > 0:\r\n            self.ms_jar = jar\r\n            input.setText(self.ms_jar)\r\n\r\n    # confirm .jar file\r\n    def check_ms(self, input):\r\n        if os.path.exists(input.text()):\r\n            self.ms_jar = input.text()\r\n            is_jar = self.ms_jar.endswith('.jar')\r\n            if not is_jar:\r\n                self.popup_window('Not a .jar file')\r\n                self.ms_jar = \"\"\r\n        else:\r\n            self.popup_window('Path does not exist')\r\n\r\n    # browse for idconvert.exe\r\n    def set_id_path(self, input):\r\n        file, _ = QFileDialog.getOpenFileName(\r\n            parent=self,\r\n            caption='Select idconvert executable',\r\n            directory=os.getcwd(),\r\n            filter=('exe (*.exe)')\r\n        )\r\n        if len(file) > 0:\r\n            self.id_file = file\r\n            input.setText(self.id_file)\r\n\r\n    # confirm idconvert\r\n    def check_id(self, input):\r\n        if os.path.exists(input.text()):\r\n            self.id_file = input.text()\r\n            idconvert = os.access(self.id_file, os.X_OK)\r\n            if not self.id_file.endswith('.exe') or not idconvert:\r\n                self.popup_window('Not an .exe file or not executable')\r\n                self.id_file = ''\r\n        else:\r\n            self.popup_window('Path does not exist')\r\n\r\n    # browse for FASTA database\r\n    def set_fasta_path(self, input):\r\n        file, _ = QFileDialog.getOpenFileName(\r\n            parent=self,\r\n            caption='Select FASTA format protein database',\r\n            directory=os.getcwd(),\r\n            filter= 'FASTA (*.fasta)'\r\n        )\r\n        if len(file) > 0:\r\n            self.fasta = file\r\n            input.setText(self.fasta)\r\n\r\n    # confirm fasta\r\n    def check_fasta(self, input):\r\n        if os.path.exists(input.text()):\r\n            self.fasta = input.text()\r\n            if not self.fasta.endswith('.fasta'):\r\n                self.popup_window('Not a FASTA file')\r\n                self.fasta = ''\r\n        else:\r\n            self.popup_window('Path does not exist')\r\n\r\n    def popup_window(self, text):\r\n        wrong_path = QMessageBox()\r\n        wrong_path.setText(text)\r\n        wrong_path.setWindowTitle(\"Error\")\r\n        wrong_path.exec_()\r\n\r\n    def add_file(self):\r\n        file_paths, _ = QFileDialog.getOpenFileNames(\r\n            parent=self,\r\n            caption='Select input files',\r\n            directory=os.getcwd(),\r\n            filter='MS files (*.mzXML *.mzML)',\r\n        )\r\n        if len(file_paths) > 0:\r\n            os.chdir(os.path.dirname(file_paths[0]))\r\n            input_files = self.input_files\r\n            current_files = [file['raw_path'] for file in self.input_files]\r\n            for file_path in file_paths:\r\n                if file_path not in current_files:\r\n                    input_files.append({'raw_path': file_path, 'reference': False})\r\n            self.update_input_files(input_files)\r\n\r\n    #TODO identification process\r\n    def edit_file(self):\r\n        indexes = self.find_selected_files()\r\n        if len(indexes) == 0:\r\n            return\r\n\r\n        edit_file_dialog = EditFileDialog(self)\r\n        if edit_file_dialog.exec():\r\n            old_list = self.input_files\r\n            new_list = []\r\n            for i, file in enumerate(old_list):\r\n                if i in indexes:\r\n                    new_file = file\r\n                    new_file['group'] = edit_file_dialog.group\r\n                    # When only 1 file is selected mzID can have any name, if\r\n                    # multiple files are selected, the stem of raw_path and\r\n                    # ident_path will be matched.\r\n                    if len(indexes) == 1 and len(edit_file_dialog.mzid_paths) == 1:\r\n                        path = edit_file_dialog.mzid_paths[0]\r\n                        if edit_file_dialog.mzid_paths[0].endswith('.mgf'):\r\n                            path = self.process(path)\r\n                        new_file['ident_path'] = path\r\n                        os.chdir(os.path.dirname(path))  # sets directory to last identification file added\r\n                    else:\r\n                        base_name = os.path.basename(file['raw_path'])\r\n                        base_name = os.path.splitext(base_name)\r\n                        stem = base_name[0]\r\n                        for mzid in edit_file_dialog.mzid_paths:\r\n                            if mzid.endswith('.mgf'):\r\n                                mzid = self.process(mzid)\r\n                            base_name = os.path.basename(mzid)\r\n                            base_name = os.path.splitext(base_name)\r\n                            mzid_stem = base_name[0]\r\n                            if mzid_stem == stem:\r\n                                new_file['ident_path'] = mzid\r\n                                break\r\n                            os.chdir(os.path.dirname(mzid))  # sets directory to last identification file added\r\n\r\n                    new_list += [new_file]\r\n                else:\r\n                    new_list += [file]\r\n            self.update_input_files(new_list)\r\n\r\n    def process(self, mgf):\r\n        # check if mzid is already in same directory\r\n        if os.path.exists(self.make_mzid_path(mgf)):\r\n            return self.make_mzid_path(mgf)\r\n\r\n        ms, ms_jar = self.get_ms()\r\n\r\n        msfragger = subprocess.run(\r\n            [\"java\", \"-Xmx32g\", \"-jar\", ms_jar, \"C:/Users/kaitl/Downloads/closed_fragger.params\", mgf],\r\n            cwd=ms,\r\n            capture_output=True\r\n        )\r\n        pep = self.make_pep_path(mgf)\r\n\r\n        id = self.get_id()\r\n        idconvert = subprocess.run([id, pep, \"-o\", os.path.dirname(mgf)], capture_output=True)\r\n\r\n        os.unlink(pep)\r\n\r\n        mzid = self.make_mzid_path(mgf)\r\n        return mzid\r\n\r\n    # split path into jar file and directory\r\n    def get_ms(self):\r\n        jar = self.ms_jar\r\n        jar_file = os.path.basename(jar)  # jar\r\n        ms_path = os.path.dirname(jar)   # directory\r\n        return ms_path, jar_file\r\n\r\n    # idconvert\r\n    def get_id(self):\r\n        id = self.id_file\r\n        return id\r\n\r\n    # msfragger places pepxml in same directory with same name\r\n    def make_pep_path(self, mgf):\r\n        return mgf.replace('.mgf', '.pepxml')\r\n\r\n    # idconvert places mzid in same directory with same name\r\n    def make_mzid_path(self, mzid):\r\n        return mzid.replace(\".mgf\", \".mzID\")\r\n\r\n    def remove_all_files(self):\r\n        self.remove_file(True)\r\n\r\n    def remove_file(self, default=False):\r\n        indexes = self.find_selected_files()\r\n        if default:\r\n            self.update_input_files([])\r\n            return\r\n        if len(indexes) > 0:\r\n            old_list = self.input_files\r\n            new_list = []\r\n            for i, file in enumerate(old_list):\r\n                if i not in indexes:\r\n                    new_list += [file]\r\n            self.update_input_files(new_list)\r\n\r\n\r\n    def find_selected_files(self):\r\n        selected_ranges = self.input_files_table.selectedRanges()\r\n        indexes = []\r\n        for sel in selected_ranges:\r\n            for i in range(sel.topRow(), sel.bottomRow() + 1):\r\n                indexes += [i]\r\n        return indexes\r\n\r\n    def update_input_files(self, input_files):\r\n        self.input_files = input_files\r\n        self.input_files_table.setRowCount(len(self.input_files))\r\n        for i, input_file in enumerate(self.input_files):\r\n            label = QLabel(input_file['raw_path'])\r\n            self.input_files_table.setCellWidget(i, 0, label)\r\n            if 'ident_path' in input_file:\r\n                self.input_files_table.setCellWidget(i, 1, QLabel(input_file['ident_path']))\r\n            if 'group' in input_file:\r\n                label = QLabel(input_file['group'])\r\n                label.setAlignment(Qt.AlignCenter)\r\n                self.input_files_table.setCellWidget(i, 2, label)\r\n            if 'reference' in input_file:\r\n                cell_widget = QWidget()\r\n                checkbox = QCheckBox()\r\n                if input_file['reference']:\r\n                    checkbox.setCheckState(Qt.Checked)\r\n                lay_out = QHBoxLayout(cell_widget)\r\n                lay_out.addWidget(checkbox)\r\n                lay_out.setAlignment(Qt.AlignCenter)\r\n                lay_out.setContentsMargins(0, 0, 0, 0)\r\n                cell_widget.setLayout(lay_out)\r\n                checkbox.stateChanged.connect(self.toggle_reference)\r\n                self.input_files_table.setCellWidget(i, 3, cell_widget)\r\n\r\n    def toggle_reference(self):\r\n        for row in range(self.input_files_table.rowCount()):\r\n            checkbox = self.input_files_table.cellWidget(row, 3).children()[1]\r\n            self.input_files[row]['reference'] = checkbox.isChecked()\r\n\r\n    def parameters_tab_ui(self):\r\n        # TODO: Maybe we should add the constrains and default values in\r\n        # a dictionary format. Parameters are not going to change often, so\r\n        # probably is fine with hardcoding the ranges here.\r\n        LARGE = 1000000000\r\n\r\n        # TODO: Add tooltips.\r\n        # TODO: Make sure constrains are set properly.\r\n\r\n        self.update_allowed = False\r\n\r\n        #\r\n        # Instruments\r\n        #\r\n        self.inst_settings_box = QGroupBox('Instrument Settings')\r\n        grid_layout_inst = QGridLayout()\r\n\r\n        self.inst_type = QComboBox()\r\n        self.inst_type.addItems(['orbitrap', 'tof', 'ft-icr', 'quadrupole'])\r\n        self.inst_type.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = 'The type of mass analyser used to acquire the data.'\r\n        grid_layout_inst.addWidget(ParameterItem('Instrument type', tooltip, self.inst_type), 0, 0)\r\n\r\n        self.res_ms1 = QSpinBox()\r\n        self.res_ms1.setRange(-LARGE, LARGE)\r\n        self.res_ms1.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'MS1 resolution set on the mass spectrometer at the time of data acquisition.'\r\n        grid_layout_inst.addWidget(ParameterItem('Resolution MS1', tooltip, self.res_ms1), 0, 1)\r\n\r\n        self.res_ms2 = QSpinBox()\r\n        self.res_ms2.setRange(-LARGE, LARGE)\r\n        self.res_ms2.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'MS/MS resolution set on the mass spectrometer at the time of data acquisition.'\r\n        grid_layout_inst.addWidget(ParameterItem('Resolution MS2', tooltip, self.res_ms2), 0, 2)\r\n\r\n        self.reference_mz = QSpinBox()\r\n        self.reference_mz.setRange(-LARGE, LARGE)\r\n        self.reference_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Reference m/z at which the resolution is calculated.'\r\n        grid_layout_inst.addWidget(ParameterItem('Reference m/z', tooltip, self.reference_mz), 1, 0)\r\n\r\n        self.avg_fwhm_rt = QSpinBox()\r\n        self.avg_fwhm_rt.setRange(-LARGE, LARGE)\r\n        self.avg_fwhm_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Expected full-width half-maximum width of chromatographic peaks.'\r\n        grid_layout_inst.addWidget(ParameterItem('Avg FWHM RT', tooltip, self.avg_fwhm_rt), 1, 1)\r\n\r\n        self.inst_settings_box.setLayout(grid_layout_inst)\r\n\r\n        #\r\n        # Raw data\r\n        #\r\n        self.raw_data_box = QGroupBox('Raw Data')\r\n        grid_layout_raw_data = QGridLayout()\r\n\r\n        self.min_mz = QDoubleSpinBox()\r\n        self.min_mz.setRange(0, LARGE)\r\n        self.min_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.min_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Filter minimum m/z value for spectra during raw data reading.'\r\n        grid_layout_raw_data.addWidget(ParameterItem('Min m/z', tooltip, self.min_mz), 0, 0)\r\n\r\n        self.max_mz = QDoubleSpinBox()\r\n        self.max_mz.setRange(0, LARGE)\r\n        self.max_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.max_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Filter maximum m/z value for spectra during raw data reading.'\r\n        grid_layout_raw_data.addWidget(ParameterItem('Max m/z', tooltip, self.max_mz), 0, 1)\r\n\r\n        self.polarity = QComboBox()\r\n        self.polarity.addItems(['positive', 'negative', 'both'])\r\n        self.polarity.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Filter polarity (Positive '+', negative '-', or any) for spectra during raw data reading.\r\n                  This should only be modified if the raw data file contains both positive and negative polarity spectra.''')\r\n        grid_layout_raw_data.addWidget(ParameterItem('Polarity', tooltip, self.polarity), 0, 2)\r\n\r\n        self.min_rt = QDoubleSpinBox()\r\n        self.min_rt.setRange(0, LARGE)\r\n        self.min_rt.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.min_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Filter minimum retention time value for spectra during raw data reading.'\r\n        grid_layout_raw_data.addWidget(ParameterItem('Min retention time', tooltip, self.min_rt), 1, 0)\r\n\r\n        self.max_rt = QDoubleSpinBox()\r\n        self.max_rt.setRange(0, LARGE)\r\n        self.max_rt.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.max_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Filter maximum retention time value for spectra during raw data reading.'\r\n        grid_layout_raw_data.addWidget(ParameterItem('Max retention time', tooltip, self.max_rt), 1, 1)\r\n\r\n        self.raw_data_box.setLayout(grid_layout_raw_data)\r\n\r\n        #\r\n        # Quantification\r\n        #\r\n        self.quantification_box = QGroupBox('Quantification')\r\n        grid_layout_resamp = QGridLayout()\r\n\r\n        self.num_samples_mz = QSpinBox()\r\n        self.num_samples_mz.setRange(-LARGE, LARGE)\r\n        self.num_samples_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Number of sampling points per full-width half-maximum in m/z.\r\n                  If the memory consumption is too high it can be reduced at\r\n                  the cost of potentially missing peaks or obtaining less accurate fitting.''')\r\n        grid_layout_resamp.addWidget(ParameterItem('Number of samples m/z', tooltip, self.num_samples_mz), 0, 0)\r\n\r\n        self.num_samples_rt = QSpinBox()\r\n        self.num_samples_rt.setRange(-LARGE, LARGE)\r\n        self.num_samples_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Number of sampling points per full-width half-maximum in retention time.\r\n                  If the memory consumption is too high it can be reduced at the\r\n                  cost of potentially missing peaks or obtaining less accurate fitting.''')\r\n        grid_layout_resamp.addWidget(ParameterItem('Number of samples rt', tooltip, self.num_samples_rt), 0, 1)\r\n\r\n        self.smoothing_coefficient_mz = QDoubleSpinBox()\r\n        self.smoothing_coefficient_mz.setRange(-LARGE, LARGE)\r\n        self.smoothing_coefficient_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.smoothing_coefficient_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Amount of smoothing applied for resampling in the m/z dimension.'\r\n        grid_layout_resamp.addWidget(\r\n            ParameterItem('Smoothing coefficient (m/z)', tooltip, self.smoothing_coefficient_mz), 0, 2)\r\n\r\n        self.smoothing_coefficient_rt = QDoubleSpinBox()\r\n        self.smoothing_coefficient_rt.setRange(-LARGE, LARGE)\r\n        self.smoothing_coefficient_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.smoothing_coefficient_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Amount of smoothing applied for resampling in the retention time dimension.'\r\n        grid_layout_resamp.addWidget(\r\n            ParameterItem('Smoothing coefficient (rt)', tooltip, self.smoothing_coefficient_rt), 1, 0)\r\n\r\n        self.max_peaks = QSpinBox()\r\n        self.max_peaks.setRange(-LARGE, LARGE)\r\n        self.max_peaks.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Maximum number of peaks per file being detected at isotope level in decreasing intensity order.'\r\n        grid_layout_resamp.addWidget(ParameterItem('Max number of peaks', tooltip, self.max_peaks), 2, 0)\r\n\r\n        self.feature_detection_charge_state_min = QSpinBox()\r\n        self.feature_detection_charge_state_min.setRange(1, LARGE)\r\n        self.feature_detection_charge_state_min.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Feature detection charge state min.'\r\n        grid_layout_resamp.addWidget(\r\n            ParameterItem('Feature detection min charge', tooltip, self.feature_detection_charge_state_min), 1, 1)\r\n\r\n        self.feature_detection_charge_state_max = QSpinBox()\r\n        self.feature_detection_charge_state_max.setRange(1, LARGE)\r\n        self.feature_detection_charge_state_max.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Feature detection charge state max.'\r\n        grid_layout_resamp.addWidget(\r\n            ParameterItem('Feature detection max charge', tooltip, self.feature_detection_charge_state_max), 1, 2)\r\n\r\n        self.quantification_box.setLayout(grid_layout_resamp)\r\n\r\n        #\r\n        # Warp2D\r\n        #\r\n        self.warp_box = QGroupBox('Warp2D')\r\n        grid_layout_warp = QGridLayout()\r\n\r\n        self.warp2d_slack = QSpinBox()\r\n        self.warp2d_slack.setRange(-LARGE, LARGE)\r\n        self.warp2d_slack.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of points allowed to move for each anchor node during retention time alignment.'\r\n        grid_layout_warp.addWidget(ParameterItem('Slack', tooltip, self.warp2d_slack), 0, 0)\r\n\r\n        self.warp2d_window_size = QSpinBox()\r\n        self.warp2d_window_size.setRange(-LARGE, LARGE)\r\n        self.warp2d_window_size.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of points between anchor points.'\r\n        grid_layout_warp.addWidget(ParameterItem('Window Size', tooltip, self.warp2d_window_size), 0, 1)\r\n\r\n        self.warp2d_num_points = QSpinBox()\r\n        self.warp2d_num_points.setRange(-LARGE, LARGE)\r\n        self.warp2d_num_points.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of points in which the minimum and maximum retention time range will be discretized.'\r\n        grid_layout_warp.addWidget(ParameterItem('Number of points', tooltip, self.warp2d_num_points), 0, 2)\r\n\r\n        self.warp2d_rt_expand_factor = QDoubleSpinBox()\r\n        self.warp2d_rt_expand_factor.setRange(-LARGE, LARGE)\r\n        self.warp2d_rt_expand_factor.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.warp2d_rt_expand_factor.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Expansion of the retention time range to avoid edge effects at the min/max nodes.'\r\n        grid_layout_warp.addWidget(ParameterItem('Expand factor rt', tooltip, self.warp2d_rt_expand_factor), 1, 0)\r\n        self.warp_box.setLayout(grid_layout_warp)\r\n\r\n        self.warp2d_peaks_per_window = QSpinBox()\r\n        self.warp2d_peaks_per_window.setRange(-LARGE, LARGE)\r\n        self.warp2d_peaks_per_window.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of peaks used for similarity calculation in each alignment window.'\r\n        grid_layout_warp.addWidget(ParameterItem('Peaks per window', tooltip, self.warp2d_peaks_per_window), 1, 1)\r\n\r\n        self.warp_box.setLayout(grid_layout_warp)\r\n\r\n        #\r\n        # MetaMatch\r\n        #\r\n        self.meta_box = QGroupBox('MetaMatch')\r\n        grid_layout_meta = QGridLayout()\r\n\r\n        self.metamatch_fraction = QDoubleSpinBox()\r\n        self.metamatch_fraction.setRange(-LARGE, LARGE)\r\n        self.metamatch_fraction.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.metamatch_fraction.valueChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Minimum percentage of peak presence (value between 0 and 1) in at least\r\n        one sample group to be included in Metamatch result.\r\n        For example, if there are 10 samples in group A and 10 in group B,\r\n        for a fraction value of 0.7, we consider a valid cluster if there are \r\n        matched peaks present in at least 7 samples in at least one of the sample group.''')\r\n        grid_layout_meta.addWidget(ParameterItem('Fraction of samples', tooltip, self.metamatch_fraction), 0, 0)\r\n\r\n        self.metamatch_n_sig_mz = QDoubleSpinBox()\r\n        self.metamatch_n_sig_mz.setRange(-LARGE, LARGE)\r\n        self.metamatch_n_sig_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.metamatch_n_sig_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of standard deviations to use as tolerance for m/z radius.'\r\n        grid_layout_meta.addWidget(ParameterItem('Number of sigma (m/z)', tooltip, self.metamatch_n_sig_mz), 0, 1)\r\n\r\n        self.metamatch_n_sig_rt = QDoubleSpinBox()\r\n        self.metamatch_n_sig_rt.setRange(-LARGE, LARGE)\r\n        self.metamatch_n_sig_rt.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.metamatch_n_sig_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of standard deviations to use as tolerance for retention time radius.'\r\n        grid_layout_meta.addWidget(ParameterItem('Number of sigma (rt)', tooltip, self.metamatch_n_sig_rt), 0, 2)\r\n\r\n        self.meta_box.setLayout(grid_layout_meta)\r\n\r\n        #\r\n        # Identification\r\n        #\r\n        self.ident_box = QGroupBox('Identification')\r\n        grid_layout_ident = QGridLayout()\r\n\r\n        self.ident_max_rank_only = QCheckBox()\r\n        self.ident_max_rank_only.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Only select the most confident PSM from each MS/MS spectra.'\r\n        grid_layout_ident.addWidget(ParameterItem('Max rank only', tooltip, self.ident_max_rank_only), 0, 0)\r\n\r\n        self.ident_require_threshold = QCheckBox()\r\n        self.ident_require_threshold.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Read only identifications that meet the target-decoy false discovery rate threshold.'\r\n        grid_layout_ident.addWidget(ParameterItem('Require threshold', tooltip, self.ident_require_threshold), 0, 1)\r\n\r\n        self.ident_ignore_decoy = QCheckBox()\r\n        self.ident_ignore_decoy.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Ignore PSM that have been detected as decoys by the identification engine.'\r\n        grid_layout_ident.addWidget(ParameterItem('Ignore decoy', tooltip, self.ident_ignore_decoy), 0, 2)\r\n\r\n        self.link_n_sig_mz = QDoubleSpinBox()\r\n        self.link_n_sig_mz.setRange(-LARGE, LARGE)\r\n        self.link_n_sig_mz.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.link_n_sig_mz.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Tolerance for ms2 events and identification linking measured in number of standard deviations for (m/z)'\r\n        grid_layout_ident.addWidget(ParameterItem('Max number of sigma for linking (m/z)', tooltip, self.link_n_sig_mz),\r\n                                    1, 0)\r\n\r\n        self.link_n_sig_rt = QDoubleSpinBox()\r\n        self.link_n_sig_rt.setRange(-LARGE, LARGE)\r\n        self.link_n_sig_rt.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.link_n_sig_rt.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Tolerance for ms2 events and identification linking measured in number of standard deviations for (rt)'\r\n        grid_layout_ident.addWidget(ParameterItem('Max number of sigma for linking (rt)', tooltip, self.link_n_sig_rt),\r\n                                    1, 1)\r\n\r\n        self.ident_box.setLayout(grid_layout_ident)\r\n\r\n        #\r\n        # Quality Control\r\n        #\r\n        self.qual_box = QGroupBox('Quality Control')\r\n        grid_layout_qual = QGridLayout()\r\n\r\n        self.similarity_num_peaks = QSpinBox()\r\n        self.similarity_num_peaks.setRange(-LARGE, LARGE)\r\n        self.similarity_num_peaks.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Number of peaks used for the similarity matrix calculation.'\r\n        grid_layout_qual.addWidget(ParameterItem('Similarity number of peaks', tooltip, self.similarity_num_peaks), 0,\r\n                                   0)\r\n\r\n        self.qc_plot_palette = QComboBox()\r\n        self.qc_plot_palette.addItems(['husl', 'crest', 'Spectral', 'flare', 'mako'])\r\n        self.qc_plot_palette.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = 'Plot color palette.'\r\n        grid_layout_qual.addWidget(ParameterItem('Plot color palette', tooltip, self.qc_plot_palette), 0, 1)\r\n\r\n        self.qc_plot_extension = QComboBox()\r\n        self.qc_plot_extension.addItems(['png', 'pdf', 'eps'])\r\n        self.qc_plot_extension.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = 'Plot image format'\r\n        grid_layout_qual.addWidget(ParameterItem('Plot image format', tooltip, self.qc_plot_extension), 0, 2)\r\n\r\n        # This could be either text 'dynamic' or a double between 0.0-1.0. If\r\n        # set to 0.0 it will be considered dynamic.\r\n        self.qc_plot_fill_alpha = QDoubleSpinBox()\r\n        self.qc_plot_fill_alpha.setRange(0.0, 1.0)\r\n        self.qc_plot_fill_alpha.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_fill_alpha.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Transparency amount for fill plots.'\r\n        grid_layout_qual.addWidget(ParameterItem('Fill alpha', tooltip, self.qc_plot_fill_alpha), 1, 0)\r\n\r\n        self.qc_plot_line_style = QComboBox()\r\n        self.qc_plot_line_style.addItems(['fill', 'line'])\r\n        self.qc_plot_line_style.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = 'For line plots select if pure lines or fill plots should be used.'\r\n        grid_layout_qual.addWidget(ParameterItem('Line style', tooltip, self.qc_plot_line_style), 1, 1)\r\n\r\n        self.qc_plot_font_family = QComboBox()\r\n        self.qc_plot_font_family.addItems(['sans-serif', 'serif'])\r\n        self.qc_plot_font_family.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = 'Font family.'\r\n        grid_layout_qual.addWidget(ParameterItem('Font family', tooltip, self.qc_plot_font_family), 1, 2)\r\n\r\n        self.qc_plot_dpi = QSpinBox()\r\n        self.qc_plot_dpi.setRange(1, 1000)\r\n        self.qc_plot_dpi.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Plot dpi.'\r\n        grid_layout_qual.addWidget(ParameterItem('Plot dpi', tooltip, self.qc_plot_dpi), 2, 0)\r\n\r\n        self.qc_plot_mz_vs_sigma_mz_max_peaks = QSpinBox()\r\n        self.qc_plot_mz_vs_sigma_mz_max_peaks.setRange(10, LARGE)\r\n        self.qc_plot_mz_vs_sigma_mz_max_peaks.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'How many peaks should be plotted for the m/z vs m/z width QC plot.'\r\n        grid_layout_qual.addWidget(\r\n            ParameterItem('Max peaks for m/z vs peak width m/z', tooltip, self.qc_plot_mz_vs_sigma_mz_max_peaks), 2, 1)\r\n\r\n        self.qc_plot_line_alpha = QDoubleSpinBox()\r\n        self.qc_plot_line_alpha.setRange(0.0, 1.0)\r\n        self.qc_plot_line_alpha.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_line_alpha.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Transparency amount for line plots.'\r\n        grid_layout_qual.addWidget(ParameterItem('Line alpha', tooltip, self.qc_plot_line_alpha), 2, 2)\r\n\r\n        self.qc_plot_scatter_alpha = QDoubleSpinBox()\r\n        self.qc_plot_scatter_alpha.setRange(0.0, 1.0)\r\n        self.qc_plot_scatter_alpha.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_scatter_alpha.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Transparency amount for scatter plots.'\r\n        grid_layout_qual.addWidget(ParameterItem('Scatter alpha', tooltip, self.qc_plot_scatter_alpha), 3, 0)\r\n\r\n        self.qc_plot_scatter_size = QDoubleSpinBox()\r\n        self.qc_plot_scatter_size.setRange(0.1, 10.0)\r\n        self.qc_plot_scatter_size.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_scatter_size.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Size of scatter points in QC plots.'\r\n        grid_layout_qual.addWidget(ParameterItem('Scatter size', tooltip, self.qc_plot_scatter_size), 3, 1)\r\n\r\n        self.qc_plot_min_dynamic_alpha = QDoubleSpinBox()\r\n        self.qc_plot_min_dynamic_alpha.setRange(0.1, 10.0)\r\n        self.qc_plot_min_dynamic_alpha.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_min_dynamic_alpha.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'When using dynamic transparency, select a minimum alpha level to avoid too faint plots when many samples are present.'\r\n        grid_layout_qual.addWidget(ParameterItem('Min dynamic alpha', tooltip, self.qc_plot_min_dynamic_alpha), 3, 2)\r\n\r\n        self.qc_plot_font_size = QDoubleSpinBox()\r\n        self.qc_plot_font_size.setRange(1.0, 15.0)\r\n        self.qc_plot_font_size.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_font_size.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Font size.'\r\n        grid_layout_qual.addWidget(ParameterItem('Font size', tooltip, self.qc_plot_font_size), 4, 0)\r\n\r\n        self.qc_plot_fig_size_x = QDoubleSpinBox()\r\n        self.qc_plot_fig_size_x.setRange(1.0, 15.0)\r\n        self.qc_plot_fig_size_x.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_fig_size_x.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Figure size X.'\r\n        grid_layout_qual.addWidget(ParameterItem('Figure size X', tooltip, self.qc_plot_fig_size_x), 4, 1)\r\n\r\n        self.qc_plot_fig_size_y = QDoubleSpinBox()\r\n        self.qc_plot_fig_size_y.setRange(1.0, 15.0)\r\n        self.qc_plot_fig_size_y.setStepType(QAbstractSpinBox.AdaptiveDecimalStepType)\r\n        self.qc_plot_fig_size_y.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Figure size Y.'\r\n        grid_layout_qual.addWidget(ParameterItem('Figure size Y', tooltip, self.qc_plot_fig_size_y), 4, 2)\r\n\r\n        self.qc_plot_per_file = QCheckBox()\r\n        self.qc_plot_per_file.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Whether to plot QC plots for individual files or combine them into a common figure.'\r\n        grid_layout_qual.addWidget(ParameterItem('Plot per file', tooltip, self.qc_plot_per_file), 5, 0)\r\n\r\n        self.qc_plot_fig_legend = QCheckBox()\r\n        self.qc_plot_fig_legend.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Whether to show the legend in QC plots.'\r\n        grid_layout_qual.addWidget(ParameterItem('Figure legend', tooltip, self.qc_plot_fig_legend), 5, 1)\r\n\r\n        self.qual_box.setLayout(grid_layout_qual)\r\n\r\n        #\r\n        # Quantitive Table Generation\r\n        #\r\n        self.quantt_box = QGroupBox('Quantitive Table Generation')\r\n        grid_layout_quantt = QGridLayout()\r\n\r\n        self.quant_isotopes = QComboBox()\r\n        self.quant_isotopes.addItems(['height', 'volume'])\r\n        self.quant_isotopes.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc(''' Isotope quantification method for the quantitative table generation.\r\n                  \\'Height\\': Fitted isotope peak height,\r\n                  \\'Volume\\': Volume of the 3D isotope peak.''')\r\n        grid_layout_quantt.addWidget(ParameterItem('Isotopes', tooltip, self.quant_isotopes), 0, 0)\r\n\r\n        self.quant_features = QComboBox()\r\n        self.quant_features.addItems(\r\n            ['monoisotopic_height', 'monoisotopic_volume', 'total_height', 'total_volume', 'max_height', 'max_volume'])\r\n        self.quant_features.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Feature quantification method for the quantitative table generation.\r\n                  \\'Max Height/Volume\\': Height or volume of the highest intensity isotope,\r\n                  \\'Monoisotopic Height/Volume\\': Height or volume of the monoisotopic peak,\r\n                  \\'Total Height/Volume\\': Sum of heights or volumes of all isotopic peaks in the feature.''')\r\n        grid_layout_quantt.addWidget(ParameterItem('Features', tooltip, self.quant_features), 0, 1)\r\n\r\n        self.quant_features_charge_state_filter = QCheckBox()\r\n        self.quant_features_charge_state_filter.stateChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc(''''Whether to remove feature annotations from quantitative tables \r\n        where charge state of the detected features don't mach the one given by the identification engine.''')\r\n        grid_layout_quantt.addWidget(\r\n            ParameterItem('Features charge state filter', tooltip, self.quant_features_charge_state_filter), 0, 2)\r\n\r\n        self.quant_ident_linkage = QComboBox()\r\n        self.quant_ident_linkage.addItems(['theoretical_mz', 'msms_event'])\r\n        self.quant_ident_linkage.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Method linking PSM with quantified isotopes.\r\n                  \\'Theoretical m/z\\': Link identifiations based on the theoretical monoisotopic m/z calculated by the identification engine,\r\n                  \\'MS/MS event\\': Link identifications to the closest isotope in m/z and retention time from the occurance of the MS/MS event.''')\r\n        grid_layout_quantt.addWidget(ParameterItem('Ident linkage', tooltip, self.quant_ident_linkage), 1, 0)\r\n\r\n        self.quant_consensus = QCheckBox()\r\n        self.quant_consensus.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'When selected, a sequence consensus is generated for the quantitative table.'\r\n        grid_layout_quantt.addWidget(ParameterItem('Consensus', tooltip, self.quant_consensus), 1, 1)\r\n\r\n        self.quant_consensus_min_ident = QSpinBox()\r\n        self.quant_consensus_min_ident.setRange(-LARGE, LARGE)\r\n        self.quant_consensus_min_ident.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Minimum number of samples with the same identification required for consensus sequence generation.'\r\n        grid_layout_quantt.addWidget(ParameterItem('Consensus min ident', tooltip, self.quant_consensus_min_ident), 1,\r\n                                     2)\r\n\r\n        self.quant_save_all_annotations = QCheckBox()\r\n        self.quant_save_all_annotations.stateChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc('''Whether all annotations should be saved in addition with the aggregated tables.\r\n                  Depending on the number of annotations, this might dramatically increase the disk space required.''')\r\n        grid_layout_quantt.addWidget(ParameterItem('Save all annotations', tooltip, self.quant_save_all_annotations), 2,\r\n                                     0)\r\n\r\n        self.quant_proteins_min_peptides = QSpinBox()\r\n        self.quant_proteins_min_peptides.setRange(1, 50)\r\n        self.quant_proteins_min_peptides.valueChanged.connect(self.update_parameters)\r\n        tooltip = 'Minimum number of peptides needed for considering a protein for quantification.'\r\n        grid_layout_quantt.addWidget(ParameterItem('Consensus min peptide', tooltip, self.quant_proteins_min_peptides),\r\n                                     2, 1)\r\n\r\n        self.quant_proteins_remove_subset_proteins = QCheckBox()\r\n        self.quant_proteins_remove_subset_proteins.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'Whether to remove proteins whose peptides are entirely contained within another group with longer number of evidence peptides when performing protein inference.'\r\n        grid_layout_quantt.addWidget(\r\n            ParameterItem('Remove subset proteins', tooltip, self.quant_proteins_remove_subset_proteins), 2, 2)\r\n\r\n        self.quant_proteins_ignore_ambiguous_peptides = QCheckBox()\r\n        self.quant_proteins_ignore_ambiguous_peptides.stateChanged.connect(self.update_parameters)\r\n        tooltip = 'When performing protein inference, select if peptides with ambiguous protein identifications should be ignored.'\r\n        grid_layout_quantt.addWidget(\r\n            ParameterItem('Ignore ambiguous peptides', tooltip, self.quant_proteins_ignore_ambiguous_peptides), 3, 0)\r\n\r\n        self.quant_proteins_quant_type = QComboBox()\r\n        self.quant_proteins_quant_type.addItems(['razor', 'unique', 'all'])\r\n        self.quant_proteins_quant_type.currentIndexChanged.connect(self.update_parameters)\r\n        tooltip = inspect.cleandoc(''' Type of quantification used for protein inference:\r\n            - unique: only unique peptides will be used for quantification.\r\n            - razor: same as unique plus peptides assigned as most likely due to Occam's razor constrain.\r\n            - all: All peptides will be used for quantification. Shared peptides can be used more than once.''')\r\n        grid_layout_quantt.addWidget(\r\n            ParameterItem('Protein quantification type', tooltip, self.quant_proteins_quant_type), 3, 1)\r\n\r\n        self.quantt_box.setLayout(grid_layout_quantt)\r\n\r\n        # Enable scrolling\r\n        content_widget = QWidget()\r\n        self.parameters_tab.setWidget(content_widget)\r\n        self.parameters_tab.setWidgetResizable(True)\r\n\r\n        layout = QVBoxLayout()\r\n        layout.addWidget(self.inst_settings_box)\r\n        layout.addWidget(self.raw_data_box)\r\n        layout.addWidget(self.quantification_box)\r\n        layout.addWidget(self.warp_box)\r\n        layout.addWidget(self.meta_box)\r\n        layout.addWidget(self.ident_box)\r\n        layout.addWidget(self.quantt_box)\r\n        layout.addWidget(self.qual_box)\r\n\r\n        content_widget.setLayout(layout)\r\n        self.update_allowed = True\r\n\r\n    def update_parameters(self):\r\n        if not self.update_allowed:\r\n            return\r\n\r\n        self.parameters['instrument_type'] = self.inst_type.currentText().lower()\r\n        self.parameters['resolution_ms1'] = self.res_ms1.value()\r\n        self.parameters['resolution_msn'] = self.res_ms2.value()\r\n        self.parameters['reference_mz'] = self.reference_mz.value()\r\n        self.parameters['avg_fwhm_rt'] = self.avg_fwhm_rt.value()\r\n        self.parameters['num_samples_mz'] = self.num_samples_mz.value()\r\n        self.parameters['num_samples_rt'] = self.num_samples_rt.value()\r\n        self.parameters['smoothing_coefficient_mz'] = self.smoothing_coefficient_mz.value()\r\n        self.parameters['smoothing_coefficient_rt'] = self.smoothing_coefficient_rt.value()\r\n        self.parameters['warp2d_slack'] = self.warp2d_slack.value()\r\n        self.parameters['warp2d_window_size'] = self.warp2d_window_size.value()\r\n        self.parameters['warp2d_num_points'] = self.warp2d_num_points.value()\r\n        self.parameters['warp2d_rt_expand_factor'] = self.warp2d_rt_expand_factor.value()\r\n        self.parameters['warp2d_peaks_per_window'] = self.warp2d_peaks_per_window.value()\r\n        self.parameters['metamatch_fraction'] = self.metamatch_fraction.value()\r\n        self.parameters['metamatch_n_sig_mz'] = self.metamatch_n_sig_mz.value()\r\n        self.parameters['metamatch_n_sig_rt'] = self.metamatch_n_sig_rt.value()\r\n        self.parameters['min_mz'] = self.min_mz.value()\r\n        self.parameters['max_mz'] = self.max_mz.value()\r\n        self.parameters['min_rt'] = self.min_rt.value()\r\n        self.parameters['max_rt'] = self.max_rt.value()\r\n        self.parameters['polarity'] = self.polarity.currentText()\r\n        self.parameters['max_peaks'] = self.max_peaks.value()\r\n        self.parameters['link_n_sig_mz'] = self.link_n_sig_mz.value()\r\n        self.parameters['link_n_sig_rt'] = self.link_n_sig_rt.value()\r\n        charge_state_list = list(\r\n            range(self.feature_detection_charge_state_min.value(), self.feature_detection_charge_state_max.value() + 1))\r\n        charge_state_list.reverse()\r\n        self.parameters['feature_detection_charge_states'] = charge_state_list\r\n        self.parameters['ident_max_rank_only'] = self.ident_max_rank_only.isChecked()\r\n        self.parameters['ident_require_threshold'] = self.ident_require_threshold.isChecked()\r\n        self.parameters['ident_ignore_decoy'] = self.ident_ignore_decoy.isChecked()\r\n        self.parameters['similarity_num_peaks'] = self.similarity_num_peaks.value()\r\n        self.parameters['qc_plot_palette'] = self.qc_plot_palette.currentText()\r\n        self.parameters['qc_plot_extension'] = self.qc_plot_extension.currentText()\r\n        if self.qc_plot_fill_alpha.value() == 0.0:\r\n            self.parameters['qc_plot_fill_alpha'] = 'dynamic'\r\n        else:\r\n            self.parameters['qc_plot_fill_alpha'] = self.qc_plot_fill_alpha.value()\r\n        self.parameters['qc_plot_line_alpha'] = self.qc_plot_line_alpha.value()\r\n        self.parameters['qc_plot_scatter_alpha'] = self.qc_plot_scatter_alpha.value()\r\n        self.parameters['qc_plot_scatter_size'] = self.qc_plot_scatter_size.value()\r\n        self.parameters['qc_plot_min_dynamic_alpha'] = self.qc_plot_min_dynamic_alpha.value()\r\n        self.parameters['qc_plot_per_file'] = self.qc_plot_per_file.isChecked()\r\n        self.parameters['qc_plot_line_style'] = self.qc_plot_line_style.currentText()\r\n        self.parameters['qc_plot_dpi'] = self.qc_plot_dpi.value()\r\n        self.parameters['qc_plot_font_family'] = self.qc_plot_font_family.currentText()\r\n        self.parameters['qc_plot_font_size'] = self.qc_plot_font_size.value()\r\n        self.parameters['qc_plot_fig_size_x'] = self.qc_plot_fig_size_x.value()\r\n        self.parameters['qc_plot_fig_size_y'] = self.qc_plot_fig_size_y.value()\r\n        self.parameters['qc_plot_fig_legend'] = self.qc_plot_fig_legend.isChecked()\r\n        self.parameters['qc_plot_mz_vs_sigma_mz_max_peaks'] = self.qc_plot_mz_vs_sigma_mz_max_peaks.value()\r\n        self.parameters['quant_isotopes'] = self.quant_isotopes.currentText()\r\n        self.parameters['quant_features'] = self.quant_features.currentText()\r\n        self.parameters['quant_features_charge_state_filter'] = self.quant_features_charge_state_filter.isChecked()\r\n        self.parameters['quant_ident_linkage'] = self.quant_ident_linkage.currentText()\r\n        self.parameters['quant_consensus'] = self.quant_consensus.isChecked()\r\n        self.parameters['quant_consensus_min_ident'] = self.quant_consensus_min_ident.value()\r\n        self.parameters['quant_save_all_annotations'] = self.quant_save_all_annotations.isChecked()\r\n        self.parameters['quant_proteins_min_peptides'] = self.quant_proteins_min_peptides.value()\r\n        self.parameters[\r\n            'quant_proteins_remove_subset_proteins'] = self.quant_proteins_remove_subset_proteins.isChecked()\r\n        self.parameters[\r\n            'quant_proteins_ignore_ambiguous_peptides'] = self.quant_proteins_ignore_ambiguous_peptides.isChecked()\r\n        self.parameters['quant_proteins_quant_type'] = self.quant_proteins_quant_type.currentText()\r\n\r\n\r\npop = False\r\nclass MainWindow(QMainWindow):\r\n    project_path = ''\r\n    dark = False\r\n\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        self.setWindowTitle('PASTAQ: DDA Pipeline')\r\n\r\n        # Main layout\r\n        layout = QVBoxLayout()\r\n\r\n        #Menu Bar\r\n        self.menubar = self.menuBar()\r\n        self.fileMenu = self.menubar.addMenu('File')\r\n        self.actionMenu = self.menubar.addMenu('Action')\r\n                \r\n        #New Project \r\n        self.newProj = QAction('New Project', self)\r\n        self.newProj.triggered.connect(self.new_project)\r\n        self.fileMenu.addAction(self.newProj)\r\n\r\n        #Open Project \r\n        self.openProj = QAction('Open Project', self)\r\n        self.openProj.triggered.connect(self.open_project)\r\n        self.openProj.setShortcut(QKeySequence('Ctrl+o'))\r\n        self.fileMenu.addAction(self.openProj)\r\n\r\n        #Save Project\r\n        self.save_project_btn = QAction('Save', self)\r\n        self.save_project_btn.triggered.connect(self.save_project)\r\n        self.save_project_btn.setShortcut(QKeySequence('Ctrl+s'))\r\n        self.save_project_btn.setEnabled(False)\r\n        self.fileMenu.addAction(self.save_project_btn)\r\n\r\n        #Save Project As\r\n        self.save_project_as_btn = QAction('Save as', self)\r\n        self.save_project_as_btn.triggered.connect(self.save_project_as)\r\n        self.save_project_as_btn.setEnabled(False)\r\n        self.fileMenu.addAction(self.save_project_as_btn)\r\n\r\n        #Reset button\r\n        self.reset_param_btn = QAction('Reset Parameters', self)\r\n        self.reset_param_btn.triggered.connect(self.reset_param)\r\n        self.reset_param_btn.setEnabled(False)\r\n        self.actionMenu.addAction(self.reset_param_btn)\r\n        \r\n        self.view_mode_btn = QAction('Dark Mode', self)\r\n        self.view_mode_btn.triggered.connect(self.view_mode)\r\n        self.reset_param_btn.setEnabled(True)\r\n        self.actionMenu.addAction(self.view_mode_btn)\r\n\r\n        #\r\n        # Project variables.\r\n        #\r\n        self.project_variables_container = QWidget()\r\n        project_variables_layout = QFormLayout()\r\n        self.project_name_ui = QLineEdit()\r\n        self.project_name_ui.textChanged.connect(self.set_project_name)\r\n        self.project_description_ui = QLineEdit()\r\n        self.project_description_ui.textChanged.connect(self.set_project_description)\r\n        self.project_directory_ui = QLineEdit()\r\n        project_variables_layout.addRow('Project name', self.project_name_ui)\r\n        project_variables_layout.addRow('Project description', self.project_description_ui)\r\n        project_variables_layout.addRow('Project directory', self.project_directory_ui)\r\n        self.project_directory_ui.setReadOnly(True)\r\n        self.project_variables_container.setLayout(project_variables_layout)\r\n        layout.addWidget(self.project_variables_container)\r\n\r\n        #\r\n        # Tabbed input files/parameters\r\n        #\r\n        self.parameters_container = ParametersWidget()\r\n        layout.addWidget(self.parameters_container)\r\n\r\n        #\r\n        # Run button\r\n        #\r\n        self.run_btn = QPushButton('Run')\r\n        self.run_btn.clicked.connect(self.run_pipeline)\r\n        layout.addWidget(self.run_btn)\r\n\r\n        container = QWidget()\r\n        container.setLayout(layout)\r\n\r\n        self.run_btn.setEnabled(False)\r\n        self.project_variables_container.setEnabled(False)\r\n        self.parameters_container.setEnabled(False)  # determines whether parameter tab visible or not\r\n\r\n        # Set the central widget of the Window.\r\n        self.setCentralWidget(container)\r\n        self.default_param = pastaq.default_parameters('orbitrap', 10)\r\n\r\n    def set_project_name(self):\r\n        self.parameters_container.parameters['project_name'] = self.project_name_ui.text()\r\n\r\n    def set_project_description(self):\r\n        self.parameters_container.parameters['project_description'] = self.project_description_ui.text()\r\n\r\n    def reset_param(self):\r\n        self.update_ui(True)\r\n    \r\n    def view_mode(self):\r\n        if (self.dark == False):\r\n            self.dark_mode()\r\n            self.dark = True\r\n            self.view_mode_btn.setText('Light Mode')\r\n        else:\r\n            self.light_mode()\r\n            self.dark = False\r\n            self.view_mode_btn.setText('Dark Mode')\r\n               \r\n    def dark_mode(self):\r\n        app.setStyle(\"Fusion\")\r\n        # Now use a palette to switch to dark colors:\r\n        palette = QPalette()\r\n        palette.setColor(QPalette.Window, QColor(53, 53, 53))\r\n        palette.setColor(QPalette.WindowText, Qt.white)\r\n        palette.setColor(QPalette.Base, QColor(25, 25, 25))\r\n        palette.setColor(QPalette.AlternateBase, QColor(53, 53, 53))\r\n        palette.setColor(QPalette.ToolTipBase, Qt.black)\r\n        palette.setColor(QPalette.ToolTipText, Qt.white)\r\n        palette.setColor(QPalette.Text, Qt.white)\r\n        palette.setColor(QPalette.Button, QColor(53, 53, 53))\r\n        palette.setColor(QPalette.ButtonText, Qt.white)\r\n        palette.setColor(QPalette.BrightText, Qt.red)\r\n        palette.setColor(QPalette.Link, QColor(42, 130, 218))\r\n        palette.setColor(QPalette.Highlight, QColor(42, 130, 218))\r\n        palette.setColor(QPalette.HighlightedText, Qt.black)\r\n        app.setPalette(palette)\r\n        \r\n    def light_mode(self):\r\n        app.setStyle(\"Fusion\")\r\n        palette = QPalette()\r\n        app.setPalette(palette)\r\n                \r\n    def update_ui(self, default=False):\r\n        # Project metadata.\r\n        self.project_directory_ui.setText(os.path.dirname(self.project_path))\r\n        if 'project_name' in self.parameters_container.parameters:\r\n            self.project_name_ui.setText(self.parameters_container.parameters['project_name'])\r\n        if 'project_description' in self.parameters_container.parameters:\r\n            self.project_description_ui.setText(self.parameters_container.parameters['project_description'])\r\n        if default:\r\n            params = self.default_param\r\n        else:\r\n            params = self.parameters_container.parameters\r\n\r\n        # Parameters.\r\n        self.parameters_container.update_allowed = False\r\n        self.parameters_container.inst_type.setCurrentText(params['instrument_type'])\r\n        self.parameters_container.res_ms1.setValue(params['resolution_ms1'])\r\n        self.parameters_container.res_ms2.setValue(params['resolution_msn'])\r\n        self.parameters_container.reference_mz.setValue(params['reference_mz'])\r\n        self.parameters_container.avg_fwhm_rt.setValue(params['avg_fwhm_rt'])\r\n        self.parameters_container.num_samples_mz.setValue(params['num_samples_mz'])\r\n        self.parameters_container.num_samples_rt.setValue(params['num_samples_rt'])\r\n        self.parameters_container.smoothing_coefficient_mz.setValue(params['smoothing_coefficient_mz'])\r\n        self.parameters_container.smoothing_coefficient_rt.setValue(params['smoothing_coefficient_rt'])\r\n        self.parameters_container.warp2d_slack.setValue(params['warp2d_slack'])\r\n        self.parameters_container.warp2d_window_size.setValue(params['warp2d_window_size'])\r\n        self.parameters_container.warp2d_num_points.setValue(params['warp2d_num_points'])\r\n        self.parameters_container.warp2d_rt_expand_factor.setValue(params['warp2d_rt_expand_factor'])\r\n        self.parameters_container.warp2d_peaks_per_window.setValue(params['warp2d_peaks_per_window'])\r\n        self.parameters_container.metamatch_fraction.setValue(params['metamatch_fraction'])\r\n        self.parameters_container.metamatch_n_sig_mz.setValue(params['metamatch_n_sig_mz'])\r\n        self.parameters_container.metamatch_n_sig_rt.setValue(params['metamatch_n_sig_rt'])\r\n        self.parameters_container.min_mz.setValue(params['min_mz'])\r\n        self.parameters_container.max_mz.setValue(params['max_mz'])\r\n        self.parameters_container.min_rt.setValue(params['min_rt'])\r\n        self.parameters_container.max_rt.setValue(params['max_rt'])\r\n        self.parameters_container.polarity.setCurrentText(params['polarity'])\r\n        self.parameters_container.max_peaks.setValue(params['max_peaks'])\r\n        self.parameters_container.link_n_sig_mz.setValue(params['link_n_sig_mz'])\r\n        self.parameters_container.link_n_sig_rt.setValue(params['link_n_sig_rt'])\r\n        self.parameters_container.feature_detection_charge_state_min.setValue(\r\n            min(params['feature_detection_charge_states']))\r\n        self.parameters_container.feature_detection_charge_state_max.setValue(\r\n            max(params['feature_detection_charge_states']))\r\n        self.parameters_container.similarity_num_peaks.setValue(params['similarity_num_peaks'])\r\n        self.parameters_container.qc_plot_palette.setCurrentText(params['qc_plot_palette'])\r\n        self.parameters_container.qc_plot_extension.setCurrentText(params['qc_plot_extension'])\r\n        if params['qc_plot_fill_alpha'] == 'dynamic':\r\n            self.parameters_container.qc_plot_fill_alpha.setValue(0.0)\r\n        else:\r\n            self.parameters_container.qc_plot_fill_alpha.setValue(params['qc_plot_fill_alpha'])\r\n        self.parameters_container.qc_plot_line_alpha.setValue(params['qc_plot_line_alpha'])\r\n        self.parameters_container.qc_plot_scatter_alpha.setValue(params['qc_plot_scatter_alpha'])\r\n        self.parameters_container.qc_plot_scatter_size.setValue(params['qc_plot_scatter_size'])\r\n        self.parameters_container.qc_plot_min_dynamic_alpha.setValue(params['qc_plot_min_dynamic_alpha'])\r\n        if params['qc_plot_per_file']:\r\n            self.parameters_container.qc_plot_per_file.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.qc_plot_per_file.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.qc_plot_line_style.setCurrentText(params['qc_plot_line_style'])\r\n        self.parameters_container.qc_plot_dpi.setValue(params['qc_plot_dpi'])\r\n        self.parameters_container.qc_plot_font_family.setCurrentText(params['qc_plot_font_family'])\r\n        self.parameters_container.qc_plot_font_size.setValue(params['qc_plot_font_size'])\r\n        self.parameters_container.qc_plot_fig_size_x.setValue(params['qc_plot_fig_size_x'])\r\n        self.parameters_container.qc_plot_fig_size_y.setValue(params['qc_plot_fig_size_y'])\r\n        if params['qc_plot_fig_legend']:\r\n            self.parameters_container.qc_plot_fig_legend.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.qc_plot_fig_legend.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.qc_plot_mz_vs_sigma_mz_max_peaks.setValue(params['qc_plot_mz_vs_sigma_mz_max_peaks'])\r\n        self.parameters_container.quant_isotopes.setCurrentText(params['quant_isotopes'])\r\n        self.parameters_container.quant_features.setCurrentText(params['quant_features'])\r\n        if params['quant_features_charge_state_filter']:\r\n            self.parameters_container.quant_features_charge_state_filter.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.quant_features_charge_state_filter.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.quant_ident_linkage.setCurrentText(params['quant_ident_linkage'])\r\n        if params['quant_consensus']:\r\n            self.parameters_container.quant_consensus.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.quant_consensus.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.quant_consensus_min_ident.setValue(params['quant_consensus_min_ident'])\r\n        if params['quant_save_all_annotations']:\r\n            self.parameters_container.quant_save_all_annotations.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.quant_save_all_annotations.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.quant_proteins_min_peptides.setValue(params['quant_proteins_min_peptides'])\r\n        if params['quant_proteins_remove_subset_proteins']:\r\n            self.parameters_container.quant_proteins_remove_subset_proteins.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.quant_proteins_remove_subset_proteins.setCheckState(Qt.Unchecked)\r\n        if params['quant_proteins_ignore_ambiguous_peptides']:\r\n            self.parameters_container.quant_proteins_ignore_ambiguous_peptides.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.quant_proteins_ignore_ambiguous_peptides.setCheckState(Qt.Unchecked)\r\n        self.parameters_container.quant_proteins_quant_type.setCurrentText(params['quant_proteins_quant_type'])\r\n        if params['ident_max_rank_only']:\r\n            self.parameters_container.ident_max_rank_only.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.ident_max_rank_only.setCheckState(Qt.Unchecked)\r\n        if params['ident_require_threshold']:\r\n            self.parameters_container.ident_require_threshold.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.ident_require_threshold.setCheckState(Qt.Unchecked)\r\n        if params['ident_ignore_decoy']:\r\n            self.parameters_container.ident_ignore_decoy.setCheckState(Qt.Checked)\r\n        else:\r\n            self.parameters_container.ident_ignore_decoy.setCheckState(Qt.Unchecked)\r\n\r\n        self.parameters_container.update_allowed = True\r\n\r\n    def new_project(self):\r\n        dir_path = QFileDialog.getExistingDirectory(\r\n            parent=self,\r\n            caption='Select project directory',\r\n            directory=os.getcwd(),\r\n        )\r\n        if len(dir_path) > 0:\r\n            # TODO: Check if the project file already exists and show a warning\r\n            # dialog to let the user overwrite it.\r\n            self.project_path = os.path.join(dir_path, 'parameters.json')\r\n            self.parameters_container.parameters = pastaq.default_parameters('orbitrap', 10)\r\n            self.save_project_btn.setEnabled(True)\r\n            self.save_project_as_btn.setEnabled(True)\r\n            self.run_btn.setEnabled(True)\r\n            self.reset_param_btn.setEnabled(True)\r\n            self.project_variables_container.setEnabled(True)\r\n            self.parameters_container.setEnabled(True)\r\n            self.update_ui()\r\n            self.save_project()\r\n            global pop\r\n            pop = True\r\n\r\n    def open_project(self):\r\n        file_path, _ = QFileDialog.getOpenFileName(\r\n            parent=self,\r\n            caption='Select project file',\r\n            directory=os.getcwd(),\r\n            filter='Project file (*.json)',\r\n        )\r\n        if len(file_path) > 0:\r\n            os.chdir(os.path.dirname(file_path))\r\n            tmp = json.loads(open(file_path).read())\r\n            # TODO: Validate parameters\r\n            valid = True\r\n            if valid:\r\n                self.parameters_container.parameters = tmp\r\n                self.project_path = file_path\r\n                self.save_project_btn.setEnabled(True)\r\n                self.save_project_as_btn.setEnabled(True)\r\n                self.run_btn.setEnabled(True)\r\n                self.reset_param_btn.setEnabled(True)\r\n                self.project_variables_container.setEnabled(True)\r\n                self.parameters_container.setEnabled(True)\r\n                if 'input_files' in self.parameters_container.parameters:\r\n                    self.parameters_container.update_input_files(self.parameters_container.parameters['input_files'])\r\n                self.update_ui()\r\n                global pop\r\n                pop = True\r\n\r\n    def save_project(self):\r\n        try:\r\n            with open(self.project_path, 'w') as json_file:\r\n                params = self.parameters_container.parameters\r\n                params['input_files'] = self.parameters_container.input_files\r\n                json.dump(params, json_file)\r\n        except:\r\n            error_dialog = QMessageBox()\r\n            error_dialog.setIcon(QMessageBox.Critical)\r\n            error_dialog.setText('Error')\r\n            error_dialog.setInformativeText('Can\\'t save project at the given directory')\r\n            error_dialog.setWindowTitle('Error')\r\n            error_dialog.exec_()\r\n\r\n    def closeEvent(self, event):\r\n        if pop == True:\r\n            box = QMessageBox()\r\n            box.setWindowTitle('Window Close')\r\n            box.setText('Do you want to save your work?')\r\n            box.setStandardButtons(QMessageBox.Yes | QMessageBox.No | QMessageBox.Cancel)\r\n            button_s = box.button(QMessageBox.Yes)\r\n            button_s.setText('Save and Exit')\r\n            button_d = box.button(QMessageBox.No)\r\n            button_d.setText('Discard and Exit')\r\n            button_c = box.button(QMessageBox.Cancel)\r\n            button_c.setText('Cancel')\r\n            box.exec_()\r\n            if box.clickedButton() == button_s:\r\n                self.save_project()\r\n                event.accept()\r\n            elif box.clickedButton() == button_c:\r\n                event.ignore()\r\n            else:\r\n                event.accept()\r\n\r\n    def save_project_as(self):\r\n        path = QFileDialog.getExistingDirectory(\r\n            parent=self,\r\n            caption='Select project file',\r\n            directory=os.getcwd(),\r\n        )\r\n        if len(path) > 0:\r\n            self.project_path = os.path.join(path, 'parameters.json')\r\n            self.update_ui()\r\n            self.save_project()\r\n            global pop\r\n            pop = True\r\n\r\n    def run_pipeline(self):\r\n        # Save changes before running.\r\n        self.save_project()\r\n\r\n        # Disable this window so that buttons can't be clicked.\r\n        self.run_btn.setText('Running...')\r\n        self.run_btn.setEnabled(False)\r\n        self.project_variables_container.setEnabled(False)\r\n        self.parameters_container.setEnabled(False)\r\n\r\n        # Open modal with log progress and cancel button and run pipeline\r\n        # in a different thread/fork.\r\n        pipeline_log_dialog = PipelineLogDialog(\r\n            parent=self,\r\n            params=self.parameters_container.parameters,\r\n            input_files=self.parameters_container.input_files,\r\n            output_dir=os.path.dirname(self.project_path))\r\n        if pipeline_log_dialog.exec():\r\n            print('EXIT SUCCESS')\r\n        else:\r\n            print('EXIT CANCEL')\r\n\r\n        # Restore previous button statuses.\r\n        self.run_btn.setText('Run')\r\n        self.run_btn.setEnabled(True)\r\n        self.project_variables_container.setEnabled(True)\r\n        self.parameters_container.setEnabled(True)\r\n\r\n\r\n# Initialize main window.\r\napp = QApplication(sys.argv)\r\napp.setWindowIcon(QIcon(':/icons/pastaq.png'))\r\nif platform.system() == 'Windows':\r\n    import ctypes\r\n    ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID('pastaq-gui')\r\napp.setStyle(\"Fusion\")\r\n\r\nwindow = MainWindow()\r\nwindow.resize(QSize(600, 600))\r\nwindow.show()\r\n\r\n# Start the event loop.\r\napp.exec()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app.py b/src/app.py
--- a/src/app.py	(revision 918d89cff336cce5e1ce1ec963f2937bf32a7027)
+++ b/src/app.py	(date 1650801964063)
@@ -274,6 +274,10 @@
         self.remove_file_btn.clicked.connect(self.remove_file)
         self.remove_all_files_btn = QPushButton("Remove All")
         self.remove_all_files_btn.clicked.connect(self.remove_all_files)
+        self.select_all_files_action = QAction('Select All')
+        self.select_all_files_action.triggered.connect(self.select_all_files)
+        self.select_all_files_action.setShortcut(QKeySequence('Ctrl+a'))
+
 
         self.input_file_buttons = QWidget()
         controls_layout = QHBoxLayout()
@@ -530,6 +534,8 @@
                     new_list += [file]
             self.update_input_files(new_list)
 
+    def select_all_files(self):
+        self.input_files_table.setRangeSelected(QTableWidgetSelectionRange(), [0, 1], True)
 
     def find_selected_files(self):
         selected_ranges = self.input_files_table.selectedRanges()
